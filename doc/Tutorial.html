<style>
.IdrisData {
  color: darkred
}
.IdrisType {
  color: blue
}
.IdrisBound {
  color: black
}
.IdrisFunction {
  color: darkgreen
}
.IdrisKeyword {
  font-weight: bold;
}
.IdrisComment {
  color: #b22222
}
.IdrisNamespace {
  font-style: italic;
  color: black
}
.IdrisPostulate {
  font-weight: bold;
  color: red
}
.IdrisModule {
  font-style: italic;
  color: black
}
.IdrisCode {
  display: block;
  background-color: whitesmoke;
}
</style>
<style>
body {
  width: 80%;
  max-width: 700px;
  margin: auto;
}
code {
  background-color: whitesmoke;
}
pre code {
  display: block;
}
</style>
<h1 id="tutorial-setoids">Tutorial: Setoids</h1>
<p>A <em>setoid</em> is a type equipped with an equivalence relation. Setoids come up when you need types with a better behaved equality relation, or when you want the equality relation to carry additional information. After completing this tutorial you will:</p>
<ol type="1">
<li>Know the user interface to the <code>setoid</code> package.</li>
<li>Know two different applications in which it can be used:</li>
</ol>
<ul>
<li><p>constructing types with an equality relation that’s better behaved than Idris’s built-in <code>Equal</code> type.</p></li>
<li><p>types with an equality relation that carries additional information</p></li>
</ul>
<p>If you want to see the source-code behind this tutorial, check the <a href="sources/Tutorial.md">source-code</a> out.</p>
<h2 id="equivalence-relations">Equivalence relations</h2>
<p>A <em>relation</em> over a type <code>ty</code> in Idris is any two-argument type-valued function: <code class="IdrisCode"> <span class="IdrisFunction">Rel</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Type</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Type</span><br /> <span class="IdrisFunction">Rel</span> <span class="IdrisBound">ty</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">ty</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">ty</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Type</span><br /> </code></p>
<p>This definition and its associated interfaces ship with idris’s standard library. Given a relation <code>rel : Rel ty</code> and <code>x,y : ty</code>, we can form <code>x `rel` y : Type</code>: the type of ways in which <code>x</code> and <code>y</code> can be related.</p>
<p>For example, two lists <em>overlap</em> when they have a common element: <code class="IdrisCode"> <span class="IdrisKeyword">record</span> <span class="IdrisType">Overlap</span> <span class="IdrisKeyword">{0</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Type</span><span class="IdrisKeyword">}</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">xs</span><span class="IdrisKeyword">,</span><span class="IdrisBound">ys</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">List</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">Overlapping</span><br />   <span class="IdrisFunction">common</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">a</span><br />   <span class="IdrisFunction">lhsPos</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">common</span> <span class="IdrisType"><code>Elem</code></span> <span class="IdrisBound">xs</span><br />   <span class="IdrisFunction">rhsPos</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">common</span> <span class="IdrisType"><code>Elem</code></span> <span class="IdrisBound">ys</span><br /> <br /> </code> Lists can overlap in exactly one position: <code class="IdrisCode"> <span class="IdrisFunction">Ex1</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Overlap</span> <span class="IdrisData">[1,2,3]</span> <span class="IdrisData">[6,7,2,8]</span><br /> <span class="IdrisFunction">Ex1</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Overlapping</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">common</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">2</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">lhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisData">Here</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">rhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisKeyword">(</span><span class="IdrisData">There</span> <span class="IdrisData">Here</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">}</span><br /> </code> But they can overlap in several ways: <code class="IdrisCode"> <span class="IdrisFunction">Ex2a</span> <span class="IdrisKeyword">,</span><br /> <span class="IdrisFunction">Ex2b</span> <span class="IdrisKeyword">,</span><br /> <span class="IdrisFunction">Ex2c</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Overlap</span> <span class="IdrisData">[1,2,3]</span> <span class="IdrisData">[2,3,2]</span><br /> <span class="IdrisFunction">Ex2a</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Overlapping</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">common</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">3</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">lhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisKeyword">(</span><span class="IdrisData">There</span> <span class="IdrisData">Here</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">rhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisData">Here</span><br />   <span class="IdrisKeyword">}</span><br /> <span class="IdrisFunction">Ex2b</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Overlapping</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">common</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">2</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">lhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisData">Here</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">rhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Here</span><br />   <span class="IdrisKeyword">}</span><br /> <span class="IdrisFunction">Ex2c</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Overlapping</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">common</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">2</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">lhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisData">Here</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">rhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">There</span> <span class="IdrisKeyword">(</span><span class="IdrisData">There</span> <span class="IdrisData">Here</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">}</span><br /> </code> We can think of a relation <code>rel : Rel ty</code> as the type of edges in a directed graph between vertices in <code>ty</code>:</p>
<ul>
<li><p>edges have a direction: the type <code>rel x y</code> is different to <code>rel y x</code></p></li>
<li><p>multiple different edges between the same vertices <code>e1, e2 : rel x y</code></p></li>
<li><p>self-loops between the same vertex are allowed <code>loop : rel x x</code>.</p></li>
</ul>
<p>An <em>equivalence relation</em> is a relation that’s:</p>
<ul>
<li><p><em>reflexive</em>: we guarantee a specific way in which every element is related to itself;</p></li>
<li><p><em>symmetric</em>: we can reverse an edge between two edges; and</p></li>
<li><p><em>transitive</em>: we can compose paths of related elements into a single edge.</p></li>
</ul>
<p><code class="IdrisCode"> <span class="IdrisKeyword">record</span> <span class="IdrisType">Equivalence</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">A</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Type</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">MkEquivalence</span><br />   <span class="IdrisKeyword">0</span> <span class="IdrisFunction">relation</span><span class="IdrisKeyword">:</span> <span class="IdrisFunction">Rel</span> <span class="IdrisBound">A</span><br />   <span class="IdrisFunction">reflexive</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span>       <span class="IdrisKeyword">:</span> <span class="IdrisBound">A</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">relation</span> <span class="IdrisBound">x</span> <span class="IdrisBound">x</span><br />   <span class="IdrisFunction">symmetric</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">y</span>    <span class="IdrisKeyword">:</span> <span class="IdrisBound">A</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">relation</span> <span class="IdrisBound">x</span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">relation</span> <span class="IdrisBound">y</span> <span class="IdrisBound">x</span><br />   <span class="IdrisFunction">transitive</span><span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">y</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">z</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">A</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">relation</span> <span class="IdrisBound">x</span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">relation</span> <span class="IdrisBound">y</span> <span class="IdrisBound">z</span><br />                             <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">relation</span> <span class="IdrisBound">x</span> <span class="IdrisBound">z</span><br /> </code></p>
<p>We equip the built-in relation <code>Equal</code> with the structure of an equivalence relation, using the constructor <code>Refl</code> and the stdlib functions <code>sym</code>, and <code>trans</code>: <code class="IdrisCode"> <span class="IdrisFunction">EqualEquivalence</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Equivalence</span> <span class="IdrisBound">a</span><br /> <span class="IdrisFunction">EqualEquivalence</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkEquivalence</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">relation</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">(===)</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">reflexive</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Refl</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">symmetric</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">x_eq_y</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisFunction">sym</span> <span class="IdrisBound">x_eq_y</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">transitive</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">z</span><span class="IdrisKeyword">,</span><span class="IdrisBound">x_eq_y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y_eq_z</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisFunction">trans</span> <span class="IdrisBound">x_eq_y</span> <span class="IdrisBound">y_eq_z</span><br />   <span class="IdrisKeyword">}</span><br /> </code></p>
<p>We’ll use the following relation on pairs of natural numbers as a running example. We can represent an integer as the difference between a pair of natural numbers: <code class="IdrisCode"> <span class="IdrisKeyword">infix</span> <span class="IdrisKeyword">8</span> .-.<br /> <br /> <span class="IdrisKeyword">record</span> <span class="IdrisType">INT</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">(.-.)</span><br />   <span class="IdrisFunction">pos</span><span class="IdrisKeyword">,</span> <span class="IdrisFunction">neg</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><br /> <br /> <span class="IdrisKeyword">record</span> <span class="IdrisType">SameDiff</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INT</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">Check</span><br />   <span class="IdrisFunction">same</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.pos + </span><span class="IdrisBound">y</span><span class="IdrisFunction">.neg === </span><span class="IdrisBound">y</span><span class="IdrisFunction">.pos + </span><span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span><br /> </code> The <code>SameDiff x y</code> relation is equivalent to mathematical equation that states that the difference between the positive and negative parts is identical: <br /><span class="math display"><em>x</em><sub><em>p</em><em>o</em><em>s</em></sub> − <em>x</em><sub><em>n</em><em>e</em><em>g</em></sub> = <em>y</em><sub><em>p</em><em>o</em><em>s</em></sub> − <em>y</em><sub><em>n</em><em>e</em><em>g</em></sub></span><br /> But, unlike the last equation which requires us to define integers and subtraction, its equivalent <code>(.same)</code> is expressed using only addition, and so addition on <code>Nat</code> is enough.</p>
<p>The relation <code>SameDiff</code> is an equivalence relation. The proofs are straightforward, and a good opportunity to practice Idris’s equational reasoning combinators from <code>Syntax.PreorderReasoning</code>: <code class="IdrisCode"> <span class="IdrisFunction">SameDiffEquivalence</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Equivalence</span> <span class="IdrisType">INT</span><br /> <span class="IdrisFunction">SameDiffEquivalence</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkEquivalence</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">relation</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">SameDiff</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">reflexive</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />       <span class="IdrisData">|~</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span><br />       <span class="IdrisData">~~</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisData">Refl</span><span class="IdrisKeyword">)</span><br /> </code> This equational proof represents the single-step equational proof:</p>
<p>&quot;Calculate:</p>
<ol type="1">
<li><span class="math inline"><em>x</em><sub><em>p</em><em>o</em><em>s</em></sub> + <em>x</em><sub><em>n</em><em>e</em><em>g</em></sub></span></li>
<li><span class="math inline"> = <em>x</em><sub><em>p</em><em>o</em><em>s</em></sub> + <em>x</em><sub><em>n</em><em>e</em><em>g</em></sub></span> (by reflexivity)&quot;</li>
</ol>
<p>The mnemonic behind the ASCII-art is that the first step in the proof starts with a logical-judgement symbol <span class="math inline">⊢</span>, each step continues with an equality sign <span class="math inline">=</span>, and justified by a thought bubble <code>(...)</code>. Lets continue to construct the equivalence relation over <code>SameDiff</code>: <code class="IdrisCode">   <span class="IdrisKeyword">,</span> <span class="IdrisBound">symmetric</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">x_eq_y</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />       <span class="IdrisData">|~</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span><br />       <span class="IdrisData">~~</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">..&lt;</span><span class="IdrisKeyword">(</span><span class="IdrisBound">x_eq_y</span><span class="IdrisFunction">.same</span><span class="IdrisKeyword">)</span><br /> </code> We take the proof <code>x_eq_y.same : x.pos + y.neg = y.pos + x.neg</code> and appeal to the symmetric equation. In the justification of the final step, we replace the last dot <code>(...)</code> with a left-pointing arrow <code>(..&lt;)</code>, a mnemonic for reversing the reasoning step. <code class="IdrisCode">   <span class="IdrisKeyword">,</span> <span class="IdrisBound">transitive</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">z</span><span class="IdrisKeyword">,</span><span class="IdrisBound">x_eq_y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y_eq_z</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">plusRightCancel</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span><br />       $ <span class="IdrisFunction">Calc</span> $<br />       <span class="IdrisData">|~</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span><br />       <span class="IdrisData">~~</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">solve</span> <span class="IdrisData">3</span> <span class="IdrisFunction">Monoid.Commutative.Free.Free</span><br />                                      <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Nat.Additive</span><span class="IdrisKeyword">}</span> $<br />                                      <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><br />                                   <span class="IdrisFunction">=-=</span> <span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">2</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">))</span><br />       <span class="IdrisData">~~</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">z</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">cong</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span><span class="IdrisKeyword">)</span> $ <span class="IdrisBound">y_eq_z</span><span class="IdrisFunction">.same</span><span class="IdrisKeyword">)</span><br />       <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisFunction">.pos</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span>?h02<span class="IdrisComment">{-solve 3 Monoid.Commutative.Free.Free</span><br /> <span class="IdrisComment">                                     {a = Nat.Additive} $</span><br /> <span class="IdrisComment">                                     X 0 .+. (X 1 .+. X 2)</span><br /> <span class="IdrisComment">                                 =-= (X 0 .+. X 2) .+. X 1-}</span><span class="IdrisKeyword">)</span><br />       <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisFunction">.pos</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">cong</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisFunction">.pos</span><span class="IdrisKeyword">)</span> ?h002<span class="IdrisKeyword">)</span><br />       <span class="IdrisData">~~</span> <span class="IdrisBound">z</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span>   <span class="IdrisData">…</span><span class="IdrisKeyword">(</span>?h01 <span class="IdrisComment">{-}solve 3 Monoid.Commutative.Free.Free</span><br /> <span class="IdrisComment">                                     {a = Nat.Additive} $</span><br /> <span class="IdrisComment">                                     (X 0 .+. X 1) .+. X 2</span><br /> <span class="IdrisComment">                                 =-= (X 2 .+. X 1) .+. X 0-}</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">}</span><br /> </code> This proof is more involved:</p>
<ol type="1">
<li>We appeal to the cancellation property of addition: <span class="math inline"><em>a</em> + <em>c</em> = <em>b</em> + <em>c</em> ⇒ <em>a</em> = <em>b</em></span></li>
</ol>
<p>This construction relies crucially on the cancellation property. Later, we will learn about its general form, called the INT-construction.</p>
<ol start="2" type="1">
<li>We rearrange the term, bringing the appropriate part of <code>y</code> into contact with the appropriate part of <code>z</code> and <code>x</code> to transform the term.</li>
</ol>
<p>Here we use the idris library <a href="http://www.github.com/frex-project/idris-frex"><code>Frex</code></a> that can perform such routine rearrangements for common algebraic structures. In this case, we use the commutative monoid simplifier from <code>Frex</code>. If you want to read more about <code>Frex</code>, check the <a href="https://www.denotational.co.uk/drafts/allais-brady-corbyn-kammar-yallop-frex-dependently-typed-algebraic-simplification.pdf">paper</a> out.</p>
<p>Idris’s <code>Control.Relation</code> defines interfaces for properties like reflexivity and transitivity. While the setoid package doesn’t use them, we’ll use them in a few examples.</p>
<p>The <code>Overlap</code> relation from Examples 1 and 2 is symmetric: <code class="IdrisCode"> <span class="IdrisType">Symmetric</span> <span class="IdrisKeyword">(</span><span class="IdrisType">List</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span> <span class="IdrisType">Overlap</span> <span class="IdrisKeyword">where</span><br />   <span class="IdrisFunction">symmetric</span> <span class="IdrisBound">xs_overlaps_ys</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Overlapping</span><br />     <span class="IdrisKeyword">{</span> <span class="IdrisBound">common</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">xs_overlaps_ys</span><span class="IdrisFunction">.common</span><br />     <span class="IdrisKeyword">,</span> <span class="IdrisBound">lhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">xs_overlaps_ys</span><span class="IdrisFunction">.rhsPos</span><br />     <span class="IdrisKeyword">,</span> <span class="IdrisBound">rhsPos</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">xs_overlaps_ys</span><span class="IdrisFunction">.lhsPos</span><br />     <span class="IdrisKeyword">}</span><br /> </code> However, <code>Overlap</code> is neither reflexive nor transitive:</p>
<ul>
<li><p>The empty list doesn’t overlap with itself: <code class="IdrisCode"> <span class="IdrisFunction">Ex3</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">Not</span> <span class="IdrisKeyword">(</span><span class="IdrisType">Overlap</span> <span class="IdrisData">[]</span> <span class="IdrisData">[]</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisFunction">Ex3</span> <span class="IdrisBound">nil_overlaps_nil</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">case</span> <span class="IdrisBound">nil_overlaps_nil</span><span class="IdrisFunction">.lhsPos</span> <span class="IdrisKeyword">of</span><br />   <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">impossible</span><br /> </code></p></li>
<li><p>Two lists may overlap with a middle list, but on different elements. For example: <code class="IdrisCode"> <span class="IdrisFunction">Ex4</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span> <span class="IdrisType">Overlap</span> <span class="IdrisData">[1]</span> <span class="IdrisData">[1,2]</span><br />       <span class="IdrisType">,</span> <span class="IdrisType">Overlap</span> <span class="IdrisData">[1,2]</span> <span class="IdrisData">[2]</span><br />       <span class="IdrisType">,</span> <span class="IdrisFunction">Not</span> <span class="IdrisKeyword">(</span><span class="IdrisType">Overlap</span> <span class="IdrisData">[1]</span> <span class="IdrisData">[2]</span><span class="IdrisKeyword">))</span><br /> <span class="IdrisFunction">Ex4</span> <span class="IdrisKeyword">=</span><br />   <span class="IdrisKeyword">(</span> <span class="IdrisData">Overlapping</span> <span class="IdrisData">1</span> <span class="IdrisData">Here</span> <span class="IdrisData">Here</span><br />   <span class="IdrisData">,</span> <span class="IdrisData">Overlapping</span> <span class="IdrisData">2</span> <span class="IdrisKeyword">(</span><span class="IdrisData">There</span> <span class="IdrisData">Here</span><span class="IdrisKeyword">)</span> <span class="IdrisData">Here</span><br />   <span class="IdrisData">,</span> <span class="IdrisKeyword">\</span> <span class="IdrisBound">one_overlaps_two</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">case</span> <span class="IdrisBound">one_overlaps_two</span><span class="IdrisFunction">.lhsPos</span> <span class="IdrisKeyword">of</span><br />      <span class="IdrisData">There</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">impossible</span><br />   <span class="IdrisKeyword">)</span><br /> </code> The outer lists agree on <code>1</code> and <code>2</code>, respectively, but they can’t overlap on on the first element of either, which exhausts all possibilities of overlap.</p></li>
</ul>
<h2 id="inductive-integers">Inductive <code>INTEGER</code>s</h2>
<p>We’ll show how to use setoids to verify the properties of the integers. Currently in Idris, the <code>Integer</code> type is primitive, and while expressions without any variables such as <code>2 + (3*5)</code> reduce to a single value during type-checking, expressions with variables such as <code>5 + (3 * x)</code> reduce to their primitives, which we cannot prove anything about:</p>
<pre><code>prim__add_Integer 5 (prim__mul_Integer 3 x)</code></pre>
<p>A natural alternative is to implement an <code>INTEGER</code> type inductively: <code class="IdrisCode"> <span class="IdrisKeyword">data</span> <span class="IdrisType">INTEGER</span><br />   <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisType">Nat</span><br />   <span class="IdrisKeyword">|</span> <span class="IdrisData">NegS</span> <span class="IdrisType">Nat</span><br /> <br /> </code> The constructor <code>ANat : Nat -&gt; INTEGER</code> embeds the natural numbers as the non-negative integers. The constructor <code>NegS : Nat -&gt; INTEGER</code> embeds them as negative, with <code>NegS n</code> representing the integer <code>-(1 + n)</code>. We can now implement the basic <code>Num</code>eric interface: <code class="IdrisCode"> <span class="IdrisFunction">fromInteger'</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Integer</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span><br /> <span class="IdrisFunction">fromInteger'</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">=</span><br />   <span class="IdrisKeyword">if</span> <span class="IdrisBound">x</span> <span class="IdrisFunction">&lt;</span> <span class="IdrisData">0</span><br />   <span class="IdrisKeyword">then</span> <span class="IdrisData">NegS</span> $ <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">(</span>-<span class="IdrisData">1</span> <span class="IdrisFunction">-</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">else</span> <span class="IdrisData">ANat</span> $ <span class="IdrisFunction">cast</span> <span class="IdrisBound">x</span><br /> <br /> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span><span class="IdrisKeyword">,</span><span class="IdrisBound">j</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span><br /> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisData">0</span> <span class="IdrisBound">j</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">NegS</span> <span class="IdrisBound">j</span><br /> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><br /> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisBound">k</span> <span class="IdrisBound">j</span><br /> <br /> <span class="IdrisFunction">Plus</span><span class="IdrisKeyword">,</span><span class="IdrisFunction">Mult</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span><br /> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction"><code>Plus</code></span> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction"><code>Plus</code></span> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">NegS</span> <span class="IdrisKeyword">(</span><span class="IdrisData">1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction"><code>Plus</code></span> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisBound">k</span> <span class="IdrisBound">j</span><br /> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">j</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction"><code>Plus</code></span> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">ANat_Plus_NegS</span> <span class="IdrisBound">k</span> <span class="IdrisBound">j</span><br /> <br /> <span class="IdrisFunction">NatMult</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span><br /> <span class="IdrisFunction">NatMult</span> <span class="IdrisData">0</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisData">0</span><br /> <span class="IdrisFunction">NatMult</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">x</span> <span class="IdrisFunction"><code>Plus</code></span> <span class="IdrisFunction">NatMult</span> <span class="IdrisBound">k</span> <span class="IdrisBound">x</span><br /> <br /> <span class="IdrisFunction">Neg</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INTEGER</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span><br /> <span class="IdrisFunction">Neg</span> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisData">0</span><br /> <span class="IdrisFunction">Neg</span> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">))</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><br /> <span class="IdrisFunction">Neg</span> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction"><code>Mult</code></span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">NatMult</span> <span class="IdrisBound">k</span> <span class="IdrisBound">y</span><br /> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction"><code>Mult</code></span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Neg</span> $ <span class="IdrisFunction">NatMult</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisBound">y</span><br /> <br /> <span class="IdrisType">Num</span> <span class="IdrisType">INTEGER</span> <span class="IdrisKeyword">where</span><br />   <span class="IdrisFunction">fromInteger</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">fromInteger'</span><br />   <span class="IdrisFunction">(+)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Plus</span><br />   <span class="IdrisFunction">(*)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Mult</span><br /> </code> If it’s not already clear from these definitions, reasoning about <code>INTEGER</code>s is going to involve a <em>lot</em> of case splitting. We’ll use an appropriate setoid to simplify these combinatorics.</p>
<h2 id="setoids">Setoids</h2>
<p>A <em>setoid</em> is a type equipped with an equivalence relation: <code class="IdrisCode"> <span class="IdrisKeyword">record</span> <span class="IdrisType">Setoid</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">MkSetoid</span><br />   <span class="IdrisKeyword">0</span> <span class="IdrisFunction">U</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Type</span><br />   <span class="IdrisFunction">equivalence</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Equivalence</span> <span class="IdrisBound">U</span><br /> </code></p>
<p>For example, represent the integers using this setoid: <code class="IdrisCode"> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><br /> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoid</span> <span class="IdrisType">INT</span> <span class="IdrisFunction">SameDiffEquivalence</span><br /> </code></p>
<p>We can turn any type into a setoid using the equality relation:</p>
<p><code class="IdrisCode"> <span class="IdrisType">Cast</span> <span class="IdrisType">Type</span> <span class="IdrisType">Setoid</span> <span class="IdrisKeyword">where</span><br />   <span class="IdrisFunction">cast</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoid</span> <span class="IdrisBound">x</span> <span class="IdrisFunction">EqualEquivalence</span><br /> <br /> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><br /> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">cast</span> <span class="IdrisType">INTEGER</span><br /> </code> A key difference between the setoids <code>INTEGERSetoid</code> and <code>INTSetoid</code>:</p>
<ul>
<li><p>In <code>INTEGERSetoid</code>, every equivalence class has a unique representative, by definition: <code class="IdrisCode"> <span class="IdrisFunction">uniqueRep</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisBound">x</span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">y</span><br /> <span class="IdrisFunction">uniqueRep</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisBound">prf</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">prf</span><br /> </code></p></li>
<li><p>In <code>INTSetoid</code>, we have many equivalent representatives: <code class="IdrisCode"> <span class="IdrisFunction">Ex2</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisKeyword">(</span><span class="IdrisData">0</span> <span class="IdrisData">.-.</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisFunction">Ex2</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Check</span> <span class="IdrisData">Refl</span><br /> <span class="IdrisFunction">Ex2</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />   <span class="IdrisData">|~</span> <span class="IdrisData">0</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisData">S</span> <span class="IdrisBound">k</span>       <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisData">Refl</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisData">S</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">..&lt;</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">cong</span> <span class="IdrisData">S</span> $ <span class="IdrisFunction">plusZeroRightNeutral</span> <span class="IdrisKeyword">_)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisData">0</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisData">Refl</span><span class="IdrisKeyword">)</span><br /> </code></p></li>
</ul>
<h2 id="homomorphisms">Homomorphisms</h2>
<p>We can convert between the two integer representations: <code class="IdrisCode"> <span class="IdrisFunction">toINT</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INTEGER</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INT</span><br /> <span class="IdrisFunction">toINT</span> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">k</span> <span class="IdrisData">.-.</span> <span class="IdrisData">0</span><br /> <span class="IdrisFunction">toINT</span> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">0</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">fromINT</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INTEGER</span><br /> <span class="IdrisFunction">fromINT</span> <span class="IdrisBound">pos</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">ANat</span> <span class="IdrisBound">pos</span><br /> <span class="IdrisFunction">fromINT</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><br /> <span class="IdrisFunction">fromINT</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">fromINT</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span><br /> <br /> <span class="IdrisType">Cast</span> <span class="IdrisType">INTEGER</span> <span class="IdrisType">INT</span> <span class="IdrisKeyword">where</span><br />   <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">toINT</span><br /> <br /> <span class="IdrisType">Cast</span> <span class="IdrisType">INT</span> <span class="IdrisType">INTEGER</span> <span class="IdrisKeyword">where</span><br />   <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">fromINT</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span><br /> </code> These two functions <em>preserve</em> the equivalence relations of the corresponding setoids, a property that makes them setoid <em>homomorphisms</em>: <code class="IdrisCode"> <span class="IdrisKeyword">0</span><br /> <span class="IdrisFunction">SetoidHomomorphism</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">a</span><span class="IdrisKeyword">,</span><span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Type</span><br /> <span class="IdrisFunction">SetoidHomomorphism</span> <span class="IdrisBound">a</span> <span class="IdrisBound">b</span> <span class="IdrisBound">f</span><br />   <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">a</span><span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisBound">x</span> <span class="IdrisBound">y</span><br />   <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">b</span><span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span> <span class="IdrisBound">y</span><span class="IdrisKeyword">)</span><br /> </code></p>
<p><code class="IdrisCode"> <span class="IdrisFunction">toINTHomo</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisFunction"><code>SetoidHomomorphism</code></span> <span class="IdrisFunction">INTSetoid</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">cast</span><br /> <span class="IdrisFunction">fromINTHomo</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">INTSetoid</span> <span class="IdrisFunction"><code>SetoidHomomorphism</code></span> <span class="IdrisFunction">INTEGERSetoid</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">cast</span><br /> </code></p>
<p>In one direction, the proof is in fact a special case of a general principle: <code class="IdrisCode"> <span class="IdrisFunction">(.IsMate)</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> <span class="IdrisBound">x</span> <span class="IdrisFunction"><code>SetoidHomomorphism</code></span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> <span class="IdrisBound">f</span><br /> <span class="IdrisBound">b</span><span class="IdrisFunction">.IsMate</span> <span class="IdrisBound">f</span> <span class="IdrisBound">i</span> <span class="IdrisBound">i</span> <span class="IdrisData">Refl</span> <span class="IdrisKeyword">=</span> <span class="IdrisBound">b</span><span class="IdrisFunction">.equivalence.reflexive</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span> <span class="IdrisBound">i</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">toINTHomo</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisFunction">.IsMate</span> <span class="IdrisFunction">cast</span><br /> </code> In the other direction, we’ll some lemmata: <code class="IdrisCode"> <span class="IdrisFunction">lemma1</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span><span class="IdrisKeyword">,</span><span class="IdrisBound">neg</span><span class="IdrisKeyword">,</span><span class="IdrisBound">k</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />   <span class="IdrisKeyword">((</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">))</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisFunction">lemma1</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisBound">k</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">solve</span> <span class="IdrisData">3</span> <span class="IdrisFunction">Monoid.Commutative.Free.Free</span><br />                                      <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Nat.Additive</span><span class="IdrisKeyword">}</span> $<br />                                      <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><br />                                  <span class="IdrisFunction">=-=</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">lemma2</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span><span class="IdrisKeyword">,</span><span class="IdrisBound">neg</span><span class="IdrisKeyword">,</span><span class="IdrisBound">k</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">))</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">lemma2aux</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span><span class="IdrisKeyword">,</span><span class="IdrisBound">neg</span><span class="IdrisKeyword">,</span><span class="IdrisBound">k</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">fromINT</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">))</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">fromINT</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisFunction">lemma2aux</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Refl</span><br /> <span class="IdrisFunction">lemma2aux</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">lemma2aux</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisBound">k</span><br /> <br /> <span class="IdrisFunction">lemma2</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">lemma2aux</span><br /> <span class="IdrisFunction">lemma2'</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span><span class="IdrisKeyword">,</span><span class="IdrisBound">neg</span><span class="IdrisKeyword">,</span><span class="IdrisBound">k</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">))</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisFunction">lemma2'</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisBound">k</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Calc</span> $<br />   <span class="IdrisData">|~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">((</span><span class="IdrisBound">pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">))</span><br />   <span class="IdrisData">~~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">((</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">k</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">))</span><br />                         <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">cong2</span> <span class="IdrisKeyword">(\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisFunction">cast</span> $ <span class="IdrisBound">x</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">y</span><span class="IdrisKeyword">)</span><br />                                <span class="IdrisKeyword">(</span><span class="IdrisFunction">plusCommutative</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_)</span><br />                                <span class="IdrisKeyword">(</span><span class="IdrisFunction">plusCommutative</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_))</span><br />   <span class="IdrisData">~~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">lemma2</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span><br /> </code></p>
<p><code class="IdrisCode"> <span class="IdrisFunction">fromINTHomo</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p1</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n1</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p2</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n2</span><span class="IdrisKeyword">)</span> <span class="IdrisBound">x_samediff_y</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Calc</span> $<br />   <span class="IdrisData">|~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p1</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n1</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">((</span><span class="IdrisBound">p1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n2</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n2</span><span class="IdrisKeyword">))</span>  <span class="IdrisFunction">..&lt;</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">Tutorial.lemma2'</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">to</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">}</span><br />           <span class="IdrisKeyword">((</span><span class="IdrisBound">p2</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n1</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n2</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n1</span><span class="IdrisKeyword">))</span>  <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">cong2</span> <span class="IdrisKeyword">(\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisFunction">cast</span> $ <span class="IdrisBound">x</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">y</span><span class="IdrisKeyword">)</span><br />                                            <span class="IdrisKeyword">(</span><span class="IdrisBound">x_samediff_y</span><span class="IdrisFunction">.same</span><span class="IdrisKeyword">)</span><br />                                            <span class="IdrisKeyword">(</span><span class="IdrisFunction">plusCommutative</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_))</span><br />   <span class="IdrisData">~~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p2</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n2</span><span class="IdrisKeyword">)</span>                <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">Tutorial.lemma2'</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_)</span><br /> </code></p>
<p>We define the type of setoid homomorphisms: <code class="IdrisCode"> <span class="IdrisKeyword">record</span> <span class="IdrisType">(~&gt;)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">A</span><span class="IdrisKeyword">,</span><span class="IdrisBound">B</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">MkSetoidHomomorphism</span><br />   <span class="IdrisFunction">H</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">A</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">B</span><br />   <span class="IdrisFunction">homomorphic</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">SetoidHomomorphism</span> <span class="IdrisBound">A</span> <span class="IdrisBound">B</span> <span class="IdrisBound">H</span><br /> </code></p>
<p>And use it to package the two functions as homomorphisms: <code class="IdrisCode"> <span class="IdrisFunction">ToINT</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisType">~&gt;</span> <span class="IdrisFunction">INTSetoid</span><br /> <span class="IdrisFunction">ToINT</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoidHomomorphism</span> <span class="IdrisKeyword">_</span> <span class="IdrisFunction">toINTHomo</span><br /> <span class="IdrisFunction">FromINT</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisType">~&gt;</span> <span class="IdrisFunction">INTEGERSetoid</span><br /> <span class="IdrisFunction">FromINT</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoidHomomorphism</span> <span class="IdrisKeyword">_</span> <span class="IdrisFunction">fromINTHomo</span><br /> </code></p>
<p>The setoid methodology is affectionately called <em>setoid hell</em>, because as we need to propagate the setoid equivalence through complex structures, we accrue bigger and bigger proof obligations. This situation can be ameliorated by packaging the homomorphism condition in compositional building blocks.</p>
<p>For example, the identity setoid homomorphism and the composition of setoid homomorphisms: <code class="IdrisCode"> <span class="IdrisFunction">id</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">a</span><br /> <span class="IdrisFunction">id</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoidHomomorphism</span> <span class="IdrisFunction">Prelude.id</span> $ <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">y</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">prf</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisBound">prf</span><br /> <br /> <span class="IdrisFunction">(.)</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span><span class="IdrisKeyword">,</span><span class="IdrisBound">b</span><span class="IdrisKeyword">,</span><span class="IdrisBound">c</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">}</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">b</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">c</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">b</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">c</span><br /> <span class="IdrisBound">g</span> <span class="IdrisFunction">.</span> <span class="IdrisBound">f</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoidHomomorphism</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">H</span> <span class="IdrisBound">g</span> <span class="IdrisFunction">.</span> <span class="IdrisFunction">H</span> <span class="IdrisBound">f</span><span class="IdrisKeyword">)</span> $ <span class="IdrisKeyword">\</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span><span class="IdrisKeyword">,</span><span class="IdrisBound">prf</span> <span class="IdrisKeyword">=&gt;</span><br />   <span class="IdrisBound">g</span><span class="IdrisFunction">.homomorphic</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span><span class="IdrisFunction">.homomorphic</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisBound">prf</span><span class="IdrisKeyword">)</span><br /> </code></p>
<p>As another example, we can package the information about preservation of setoid relations in more abstract setoids like this setoid of setoid homomorphisms: <code class="IdrisCode"> <span class="IdrisKeyword">0</span> <span class="IdrisFunction">SetoidHomoExtensionality</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span><span class="IdrisKeyword">,</span><span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">}</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">g</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Type</span><br /> <span class="IdrisFunction">SetoidHomoExtensionality</span> <span class="IdrisBound">f</span> <span class="IdrisBound">g</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span><br />         <span class="IdrisBound">b</span><span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span><span class="IdrisFunction">.H</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">g</span><span class="IdrisFunction">.H</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">(~~&gt;)</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">a</span><span class="IdrisKeyword">,</span><span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Setoid</span><br /> <span class="IdrisFunction">(~~&gt;)</span> <span class="IdrisBound">a</span> <span class="IdrisBound">b</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoid</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> $<br />   <span class="IdrisData">MkEquivalence</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">relation</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">SetoidHomoExtensionality</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">reflexive</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">f</span><span class="IdrisKeyword">,</span><span class="IdrisBound">v</span>       <span class="IdrisKeyword">=&gt;</span><br />       <span class="IdrisBound">b</span><span class="IdrisFunction">.equivalence.reflexive</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">f</span><span class="IdrisFunction">.H</span> <span class="IdrisBound">v</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">symmetric</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">f</span><span class="IdrisKeyword">,</span><span class="IdrisBound">g</span><span class="IdrisKeyword">,</span><span class="IdrisBound">prf</span><span class="IdrisKeyword">,</span><span class="IdrisBound">w</span> <span class="IdrisKeyword">=&gt;</span><br />       <span class="IdrisBound">b</span><span class="IdrisFunction">.equivalence.symmetric</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">prf</span> <span class="IdrisBound">w</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">transitive</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\</span><span class="IdrisBound">f</span><span class="IdrisKeyword">,</span><span class="IdrisBound">g</span><span class="IdrisKeyword">,</span><span class="IdrisBound">h</span><span class="IdrisKeyword">,</span><span class="IdrisBound">f_eq_g</span><span class="IdrisKeyword">,</span><span class="IdrisBound">g_eq_h</span><span class="IdrisKeyword">,</span><span class="IdrisBound">q</span> <span class="IdrisKeyword">=&gt;</span><br />       <span class="IdrisBound">b</span><span class="IdrisFunction">.equivalence.transitive</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span><br />         <span class="IdrisKeyword">(</span><span class="IdrisBound">f_eq_g</span> <span class="IdrisBound">q</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">g_eq_h</span> <span class="IdrisBound">q</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisKeyword">}</span><br /> </code></p>
<h2 id="isomorphisms-and-setoid-equational-reasoning">Isomorphisms and Setoid Equational Reasoning</h2>
<p>Going the round-trip <code>INTEGER</code> to <code>INT</code> and back to <code>INTEGER</code> always produces the same result: <code class="IdrisCode"> <span class="IdrisFunction">FromToId</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span><br />   <span class="IdrisFunction">INTEGERSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />     <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">to</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INT</span><span class="IdrisKeyword">}</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span><br />     <span class="IdrisBound">x</span><br /> <span class="IdrisFunction">FromToId</span> <span class="IdrisKeyword">(</span><span class="IdrisData">ANat</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Refl</span><br /> <span class="IdrisFunction">FromToId</span> <span class="IdrisKeyword">(</span><span class="IdrisData">NegS</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Refl</span><br /> </code> Going the other round-trip, <code>INT</code> to <code>INTEGER</code> and back to <code>INT</code>, may produce different results, for example <code>toINT (fromINT 8 3)</code> is <code>5 .-. 0</code>. However, the result is always equivalent to the input: <code class="IdrisCode"> <span class="IdrisFunction">ToFromId</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INT</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span><br />   <span class="IdrisFunction">INTSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />     <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">to</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">}</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span><br />     <span class="IdrisBound">x</span><br /> <span class="IdrisFunction">ToFromId'</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span><span class="IdrisKeyword">,</span><span class="IdrisBound">neg</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span><br />   <span class="IdrisFunction">INTSetoid</span> <span class="IdrisFunction">.equivalence.relation</span><br />     <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">to</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">}</span> $ <span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br />     <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">ToFromId'</span> <span class="IdrisBound">pos</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Check</span> <span class="IdrisData">Refl</span><br /> <span class="IdrisFunction">ToFromId'</span> <span class="IdrisData">0</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">k</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">Check</span> <span class="IdrisData">Refl</span><br /> </code> In the last case, we employ setoid equational reasoning: <code class="IdrisCode"> <span class="IdrisFunction">ToFromId'</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">CalcWith</span> <span class="IdrisFunction">INTSetoid</span> $<br />   <span class="IdrisData">|~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">from</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">}</span><br />           <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">))</span><br />   <span class="IdrisData">~~</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">from</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INTEGER</span><span class="IdrisKeyword">}</span><br />           <span class="IdrisKeyword">(</span><span class="IdrisFunction">cast</span> $ <span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span><br />                          <span class="IdrisFunction">.=.</span><span class="IdrisKeyword">(</span><span class="IdrisData">Refl</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span>         <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">ToFromId'</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_)</span><br />   <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">pos</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisData">S</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">..&lt;</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">lemma1</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisFunction">ToFromId</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">pos</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">neg</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">ToFromId'</span> <span class="IdrisBound">pos</span> <span class="IdrisBound">neg</span><br /> </code> Setoid equational reasoning introduces additional ‘operation’ on the thought bubble:</p>
<ul>
<li>when the middle dot is <code>=</code>, we use reflexivity to turn an appropriate propositional equality <code>Equal x y</code> to the setoid relation, with the operations <code>(.=.)</code> and <code>(.=&lt;)</code>.</li>
</ul>
<p>As with homomorphisms, we package setoid isomorphisms into a type and they too form a setoid: <code class="IdrisCode"> <span class="IdrisKeyword">record</span> <span class="IdrisType">Isomorphism</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">}</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">Fwd</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">Bwd</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">b</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">IsIsomorphism</span><br />   <span class="IdrisFunction">BwdFwdId</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">a</span> <span class="IdrisFunction">~~&gt;</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span><span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">Bwd</span> <span class="IdrisFunction">.</span> <span class="IdrisBound">Fwd</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">id</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span><br />   <span class="IdrisFunction">FwdBwdId</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">b</span> <span class="IdrisFunction">~~&gt;</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span><span class="IdrisFunction">.equivalence.relation</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">Fwd</span> <span class="IdrisFunction">.</span> <span class="IdrisBound">Bwd</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">id</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span><br /> </code></p>
<p><code class="IdrisCode"> <span class="IdrisKeyword">record</span> <span class="IdrisType">(&lt;~&gt;)</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">a</span><span class="IdrisKeyword">,</span> <span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">where</span><br />   constructor <span class="IdrisData">MkIsomorphism</span><br />   <span class="IdrisFunction">Fwd</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">a</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">b</span><br />   <span class="IdrisFunction">Bwd</span> <span class="IdrisKeyword">:</span> <span class="IdrisBound">b</span> <span class="IdrisType">~&gt;</span> <span class="IdrisBound">a</span><br /> <br />   <span class="IdrisFunction">Iso</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Isomorphism</span> <span class="IdrisBound">Fwd</span> <span class="IdrisBound">Bwd</span><br /> </code></p>
<p>and we may form a setoid <code>a &lt;~~&gt; b</code> of setoid isomorphisms between the setoids <code>a</code> and <code>b</code>, and so on.</p>
<p>Using these concepts, we can package the isomorphism up: <code class="IdrisCode"> <span class="IdrisFunction">INTEGERisoINT</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">INTSetoid</span> <span class="IdrisType">&lt;~&gt;</span> <span class="IdrisFunction">INTEGERSetoid</span><br /> <span class="IdrisFunction">INTEGERisoINT</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkIsomorphism</span><br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">Fwd</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">FromINT</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">Bwd</span> <span class="IdrisKeyword">=</span>   <span class="IdrisFunction">ToINT</span><br />   <span class="IdrisKeyword">,</span> <span class="IdrisBound">Iso</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">IsIsomorphism</span><br />       <span class="IdrisKeyword">{</span> <span class="IdrisBound">BwdFwdId</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">ToFromId</span><br />       <span class="IdrisKeyword">,</span> <span class="IdrisBound">FwdBwdId</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">FromToId</span><br />       <span class="IdrisKeyword">}</span><br />   <span class="IdrisKeyword">}</span><br /> </code></p>
<h2 id="arithmetic-on-int-uniformly-algebraic-reasoning">Arithmetic on <code>INT</code>: uniformly algebraic reasoning</h2>
<p>One advantage <code>INT</code> has over <code>INTEGER</code> is that the artihemtic in <code>INT</code> is uniform: we need no case-splitting to define addition and multiplication: <code class="IdrisCode"> <span class="IdrisFunction">Plus'</span><span class="IdrisKeyword">,</span> <span class="IdrisFunction">Mult'</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">INT</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">INT</span><br /> <span class="IdrisBound">x</span> <span class="IdrisFunction"><code>&amp;nbsp;Plus&amp;apos;&amp;nbsp;</code></span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span><br /> <span class="IdrisBound">x</span> <span class="IdrisFunction"><code>&amp;nbsp;Mult&amp;apos;&amp;nbsp;</code></span> <span class="IdrisBound">y</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">*</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">*</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">.-.</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisFunction">.pos*</span><span class="IdrisBound">y</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">*</span> <span class="IdrisBound">y</span><span class="IdrisFunction">.pos</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisType">Num</span> <span class="IdrisType">INT</span> <span class="IdrisKeyword">where</span><br />   <span class="IdrisFunction">(+)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Plus'</span><br />   <span class="IdrisFunction">(*)</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Mult'</span><br />   <span class="IdrisFunction">fromInteger</span> <span class="IdrisBound">x</span> <span class="IdrisKeyword">=</span><br />     <span class="IdrisKeyword">if</span> <span class="IdrisBound">x</span> <span class="IdrisFunction">&lt;</span> <span class="IdrisData">0</span><br />     <span class="IdrisKeyword">then</span> <span class="IdrisData">0</span> <span class="IdrisData">.-.</span> <span class="IdrisFunction">cast</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">-</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span><br />     <span class="IdrisKeyword">else</span> <span class="IdrisFunction">cast</span> <span class="IdrisBound">x</span> <span class="IdrisData">.-.</span> <span class="IdrisData">0</span><br /> </code> Concretely, we can reduce reasoning about these <code>INT</code> operations to reasoning about equational properties of <code>Nat</code>. Given a rich simplification suite, such as <a href="http://www.github.com/frex-project/idris-frex"><code>Frex</code></a>, discharging these equations is as simple as calling the simplifier. For example, lets construct the additive commutative monoid over <code>INT</code>, complete with the proofs it forms a commutative monoid that respects the setoid equivalence. <code class="IdrisCode"> <span class="IdrisFunction">INTMonoid</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">CommutativeMonoid</span><br /> <span class="IdrisFunction">INTMonoid</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">MakeModel</span><br /> </code> First, we define the structure of an algebra (<code>INT</code>, (<code>+</code>), <code>0</code>)$$: <code class="IdrisCode"> <br />   <span class="IdrisKeyword">{</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisData">MkSetoidAlgebra</span><br />     <span class="IdrisKeyword">{</span> <span class="IdrisBound">algebra</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">MkAlgebra</span><br />         <span class="IdrisKeyword">{</span> <span class="IdrisBound">U</span> <span class="IdrisKeyword">=</span> <span class="IdrisType">INT</span><br />         <span class="IdrisKeyword">,</span> <span class="IdrisBound">Sem</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\case</span><br />             <span class="IdrisData">Neutral</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">0</span><br />             <span class="IdrisData">Product</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisFunction">(+)</span><br />         <span class="IdrisKeyword">}</span><br /> </code> Next, we show the algebra structure is compatible with the setoid structure <code>INTSetoid</code>: <code class="IdrisCode">     <span class="IdrisKeyword">,</span> <span class="IdrisBound">equivalence</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">SameDiffEquivalence</span><br />     <span class="IdrisKeyword">,</span> <span class="IdrisBound">congruence</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\case</span><br />         <span class="IdrisData">MkOp</span> <span class="IdrisData">Neutral</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">\</span><span class="IdrisData">[]</span><span class="IdrisKeyword">,</span><span class="IdrisData">[]</span><span class="IdrisKeyword">,</span><span class="IdrisBound">prf</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> <span class="IdrisData">Refl</span><br />         <span class="IdrisData">MkOp</span> <span class="IdrisData">Product</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">\</span><span class="IdrisData">[</span><span class="IdrisBound">x1</span><span class="IdrisData">,</span><span class="IdrisBound">y1</span><span class="IdrisData">]</span><span class="IdrisKeyword">,</span><span class="IdrisData">[</span><span class="IdrisBound">x2</span><span class="IdrisData">,</span><span class="IdrisBound">y2</span><span class="IdrisData">]</span><span class="IdrisKeyword">,</span><span class="IdrisBound">prf</span> <span class="IdrisKeyword">=&gt;</span><br />           <span class="IdrisKeyword">let</span> <span class="IdrisKeyword">0</span> <span class="IdrisFunction">lemma</span> <span class="IdrisKeyword">:</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">u</span><span class="IdrisKeyword">,</span><span class="IdrisBound">v</span><span class="IdrisKeyword">,</span><span class="IdrisBound">w</span><span class="IdrisKeyword">,</span><span class="IdrisBound">z</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Nat</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">u</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">v</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">w</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">u</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">w</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">v</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">z</span><span class="IdrisKeyword">)</span><br />               <span class="IdrisFunction">lemma</span> <span class="IdrisBound">u</span> <span class="IdrisBound">v</span> <span class="IdrisBound">w</span> <span class="IdrisBound">z</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">solve</span> <span class="IdrisData">4</span><br />                               <span class="IdrisFunction">Monoid.Commutative.Free.Free</span><br />                                      <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Nat.Additive</span><span class="IdrisKeyword">}</span> $<br />                                      <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">2</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">3</span><span class="IdrisKeyword">))</span><br />                                  <span class="IdrisFunction">=-=</span> <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">1</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">3</span><span class="IdrisKeyword">))</span><br />           <span class="IdrisKeyword">in</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />           <span class="IdrisData">|~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x1</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y1</span><span class="IdrisFunction">.pos</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x2</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y2</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span><br />           <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x1</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x2</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">y1</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y2</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">lemma</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_)</span><br />           <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x2</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">x1</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">y2</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y1</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">cong2</span> <span class="IdrisFunction">(+)</span><br />                                                              <span class="IdrisKeyword">(</span><span class="IdrisBound">prf</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span><span class="IdrisFunction">.same</span><br />                                                              <span class="IdrisKeyword">(</span><span class="IdrisBound">prf</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span><span class="IdrisFunction">.same</span><span class="IdrisKeyword">)</span><br />           <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x2</span><span class="IdrisFunction">.pos</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y2</span><span class="IdrisFunction">.pos</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x1</span><span class="IdrisFunction">.neg</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">y1</span><span class="IdrisFunction">.neg</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">lemma</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_</span> <span class="IdrisKeyword">_)</span><br />     <span class="IdrisKeyword">}</span><br /> </code> Finally, we prove the commutative monoid axioms by calling <code>Frex</code>: <code class="IdrisCode">     <span class="IdrisKeyword">,</span> <span class="IdrisBound">validate</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">\case</span><br />       <span class="IdrisKeyword">(</span><span class="IdrisData">Mon</span> <span class="IdrisData">LftNeutrality</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">\</span><span class="IdrisData">[</span><span class="IdrisBound">p</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n</span><span class="IdrisData">]</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">INTSetoid</span><span class="IdrisKeyword">)</span><span class="IdrisFunction">.equivalence.reflexive</span> <span class="IdrisKeyword">_</span><br />       <span class="IdrisKeyword">(</span><span class="IdrisData">Mon</span> <span class="IdrisData">RgtNeutrality</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">\</span><span class="IdrisData">[</span><span class="IdrisBound">p</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n</span><span class="IdrisData">]</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />         <span class="IdrisData">|~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p</span> <span class="IdrisFunction">+</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n</span><br />         <span class="IdrisData">~~</span> <span class="IdrisBound">p</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n</span> <span class="IdrisFunction">+</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span> <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">solve</span> <span class="IdrisData">2</span><br />                               <span class="IdrisFunction">Monoid.Commutative.Free.Free</span><br />                                      <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Nat.Additive</span><span class="IdrisKeyword">}</span> $<br />                                      <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">O1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span><br />                                  <span class="IdrisFunction">=-=</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">1</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">O1</span><span class="IdrisKeyword">)))</span><br />       <span class="IdrisKeyword">(</span><span class="IdrisData">Mon</span> <span class="IdrisData">Associativity</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">\</span><span class="IdrisData">[</span><span class="IdrisBound">p1</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n1</span><span class="IdrisData">,</span> <span class="IdrisBound">p2</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n2</span><span class="IdrisData">,</span> <span class="IdrisBound">p3</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n3</span><span class="IdrisData">]</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />         <span class="IdrisData">|~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p1</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p2</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">p3</span><span class="IdrisKeyword">))</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">((</span><span class="IdrisBound">n1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n2</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n3</span><span class="IdrisKeyword">)</span><br />         <span class="IdrisData">~~</span> <span class="IdrisKeyword">((</span><span class="IdrisBound">p1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">p2</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">p3</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n1</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n2</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n3</span><span class="IdrisKeyword">))</span><br />            <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">solve</span> <span class="IdrisData">6</span> <span class="IdrisFunction">Monoid.Commutative.Free.Free</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Nat.Additive</span><span class="IdrisKeyword">}</span> $<br />               <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">1</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><span class="IdrisKeyword">))</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">3</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">4</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">5</span><span class="IdrisKeyword">)</span><br />          <span class="IdrisFunction">=-=</span> <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">3</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">4</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">5</span><span class="IdrisKeyword">))</span><br />                <span class="IdrisKeyword">)</span><br />       <span class="IdrisData">Commutativity</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisKeyword">\</span><span class="IdrisData">[</span><span class="IdrisBound">p1</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n1</span><span class="IdrisData">,</span> <span class="IdrisBound">p2</span> <span class="IdrisData">.-.</span> <span class="IdrisBound">n2</span><span class="IdrisData">]</span> <span class="IdrisKeyword">=&gt;</span> <span class="IdrisData">Check</span> $ <span class="IdrisFunction">Calc</span> $<br />         <span class="IdrisData">|~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">p2</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n2</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n1</span><span class="IdrisKeyword">)</span><br />         <span class="IdrisData">~~</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">p2</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">p1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">+</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">n1</span> <span class="IdrisFunction">+</span> <span class="IdrisBound">n2</span><span class="IdrisKeyword">)</span><br />           <span class="IdrisData">…</span><span class="IdrisKeyword">(</span><span class="IdrisFunction">solve</span> <span class="IdrisData">4</span> <span class="IdrisFunction">Monoid.Commutative.Free.Free</span> <span class="IdrisKeyword">{</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisFunction">Nat.Additive</span><span class="IdrisKeyword">}</span> $<br />               <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">0</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">1</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">2</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">3</span><span class="IdrisKeyword">))</span><br />           <span class="IdrisFunction">=-=</span> <span class="IdrisKeyword">((</span><span class="IdrisFunction">X</span> <span class="IdrisData">1</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">0</span><span class="IdrisKeyword">)</span> <span class="IdrisFunction">.+.</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">X</span> <span class="IdrisData">3</span> <span class="IdrisFunction">.+.</span> <span class="IdrisFunction">X</span> <span class="IdrisData">2</span><span class="IdrisKeyword">)))</span><br />   <span class="IdrisKeyword">}</span><br /> </code> Assuming we have a semi-ring simplifier for the arithmetic structure over the natural numbers <span class="math inline">(ℕ, ( + ), 0, ( ⋅ ), 1)</span>, we can similarly uniformly construct the multiplicative integers and the resulting ring.</p>
<h2 id="transporting-structure">Transporting structure</h2>
<p><code class="IdrisCode"> <span class="IdrisKeyword">0</span> <span class="IdrisFunction">BinOp</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Type</span><br /> <span class="IdrisFunction">BinOp</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisFunction">U</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisKeyword">0</span> <span class="IdrisFunction">Preserves</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">(</span><span class="IdrisBound">a</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span> <span class="IdrisType">**</span> <span class="IdrisFunction">BinOp</span> <span class="IdrisBound">a</span><span class="IdrisType">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">(</span><span class="IdrisBound">b</span> <span class="IdrisKeyword">:</span> <span class="IdrisType">Setoid</span> <span class="IdrisType">**</span> <span class="IdrisFunction">BinOp</span> <span class="IdrisBound">b</span><span class="IdrisType">)</span> <span class="IdrisKeyword">-&gt;</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisFunction">U</span> <span class="IdrisBound">a</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">b</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisType">Type</span><br /> <span class="IdrisKeyword">(</span>(<span class="IdrisBound">a</span> <span class="IdrisData">**</span> <span class="IdrisBound">fa</span>) <span class="IdrisFunction"><code>Preserves</code></span> (<span class="IdrisBound">b</span> <span class="IdrisData">**</span> <span class="IdrisBound">fb</span>)<span class="IdrisKeyword">)</span> <span class="IdrisBound">h</span> <span class="IdrisKeyword">=</span><br />   <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span><span class="IdrisKeyword">,</span><span class="IdrisBound">y</span> <span class="IdrisKeyword">:</span> <span class="IdrisFunction">U</span> <span class="IdrisBound">a</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">-&gt;</span> <span class="IdrisBound">h</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">x</span> <span class="IdrisBound"><code>fa</code></span> <span class="IdrisBound">y</span><span class="IdrisKeyword">)</span> <span class="IdrisKeyword">=</span> <span class="IdrisKeyword">(</span><span class="IdrisBound">h</span> <span class="IdrisBound">x</span><span class="IdrisKeyword">)</span> <span class="IdrisBound"><code>fb</code></span> <span class="IdrisKeyword">(</span><span class="IdrisBound">h</span> <span class="IdrisBound">y</span><span class="IdrisKeyword">)</span><br /> <br /> <span class="IdrisComment">–toINTisAddHomo : (INTSetoid ** (+))</span><br /> <br /> </code></p>
